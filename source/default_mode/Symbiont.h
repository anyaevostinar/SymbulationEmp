#ifndef SYMBIONT_H
#define SYMBIONT_H

#include "../../Empirical/include/emp/math/Random.hpp"
#include "../../Empirical/include/emp/tools/string_utils.hpp"
#include "SymWorld.h"
#include <set>
#include <iomanip> // setprecision
#include <sstream> // stringstream


class Symbiont: public BaseSymbiont {
protected:
  /**
    *
    * Purpose: Represents the interaction value between the host and symbiont.
    * A negative interaction value represent antagonism, while a positive
    * one represents mutualism. Zero is a neutral value.
    *
  */
  double interaction_val = 0;

public:
  /**
   * The constructor for symbiont
   */
  Symbiont(emp::Ptr<emp::Random> _random, emp::Ptr<SymWorld> _world, emp::Ptr<SymConfigBase> _config, double _intval=0.0, double _points = 0.0) :  interaction_val(_intval), Organism(_config, _world, _random, _points) {
    if (_intval == -2) {
      interaction_val = random->GetDouble(-1, 1);
    }
   if (interaction_val > 1 || interaction_val < -1) {
       throw "Invalid interaction value. Must be between -1 and 1";   // Exception for invalid interaction value
    };
  }


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To force a copy constructor to be generated by the compiler.
   */
  Symbiont(const Symbiont &) = default;


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To force a move constructor to be generated by the compiler
   */
  Symbiont(Symbiont &&) = default;


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To force a copy assignment operator to be generated by the compiler.
   */
  Symbiont & operator=(const Symbiont &) = default;


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To force a move assignment operator to be generated by the compiler.
   */
  Symbiont & operator=(Symbiont &&) = default;

  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To destruct the symbiont and remove the symbiont from the systematic.
   */
  ~Symbiont() {
    if(my_config->PHYLOGENY() == 1) {my_world->GetSymSys()->RemoveOrg(my_taxon, my_world->GetUpdate());}
  }

    /**
    * Input: None
    * 
    * Output: Name of class as string, Symbiont
    *
    * Purpose: To know which subclass the object is
    */
    std::string const GetName() {
      return  "Symbiont";
    }


  /**
   * Input: None
   *
   * Output: The double representing the symbiont's interaction value
   *
   * Purpose: To get a symbiont's interaction value.
   */
  double GetIntVal() const {return interaction_val;}


  /**
   * Input: None
   *
   * Output: The bool representing if a symbiont is a phage
   *
   * Purpose: To determine if a symbiont is a phage
   */
  bool IsPhage() {return false;}


  /**
   * Input: None
   *
   * Output: The pointer to a symbiont's host
   *
   * Purpose: To retrieve a symbiont's host
   */
  emp::Ptr<BaseHost> GetHost() {return my_host;}

  //  std::set<int> GetResTypes() const {return res_types;}


  /**
   * Input: The double representing the new interaction value of a symbiont
   *
   * Output: None
   *
   * Purpose: To set a symbiont's interaction value
   */
  void SetIntVal(double _in) {
    if ( _in > 1 || _in < -1) {
       throw "Invalid interaction value. Must be between -1 and 1";   // Exception for invalid interaction value
     }
     else {
        interaction_val = _in;
     }
  }

  //void SetResTypes(std::set<int> _in) {res_types = _in;}


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: Does nothing for now, added for backwards compatibility from phage to symbiont
   */
  void UponInjection(){
    //does nothing for now, added for backwards compatibility from phage to symbiont
  }


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To mutate a symbiont's interaction value. The mutation value is chosen
   * from a normal distribution centered on 0 with the mutation size as the standard
   * deviation.
   */
  void Mutate() override {
    double local_rate = my_config->MUTATION_RATE();
    double local_size = my_config->MUTATION_SIZE();

    if (random->GetDouble(0.0, 1.0) <= local_rate) {
      interaction_val += random->GetRandNormal(0.0, local_size);
      if(interaction_val < -1) interaction_val = -1;
      else if (interaction_val > 1) interaction_val = 1;
    }
  }

  /**
   * Input: The double representing the resources to be distributed to the symbiont
   * and (optionally) the host from whom it comes; if no host is provided, the
   * symbiont's host variable is used.
   *
   * Output: The double representing the host's resources
   *
   * Purpose: To process and distribute resources.
   */
  double ProcessResources(double host_donation,
                          emp::Ptr<Organism> host = nullptr) override;

  /**
   * Input: The double representing the resources given by the world.
   *
   * Output: None
   *
   * Purpose:  Free living symbionts specialized to interact with hosts
   * (extreme interaction value in either direction) lose some of the resources that they get from the world.
   */
  void LoseResources(double resources){
    double int_val = interaction_val;
    if(my_host.IsNull()) { // this method should only be called on free-living syms, but double check!

      if(int_val >= 0){
	      double spent = resources * int_val;
        this->AddPoints(resources - spent);
      }
      else {
        double attack = -1.0 * int_val * resources;
        this->AddPoints(resources - attack);
      }
    }
  }

  /**
   * Input: The size_t representing the location of the symbiont, and the size_t
   * representation of the symbiont's position in the host (default -1 if it doesn't have a host)
   *
   * Output: None
   *
   * Purpose: To process a symbiont, meaning to check for reproduction, distribute resources,
   * and to allow for movement
   */
   //size_t rank=-1
  void Process(emp::WorldPosition location) override {
    //ID is where they are in the world, INDEX is where they are in the host's symbiont list (or 0 if they're free living)
    if (my_host.IsNull() && my_config->FREE_LIVING_SYMS()) { //free living symbiont
      double resources = my_world->PullResources(my_config->FREE_SYM_RES_DISTRIBUTE()); //receive resources from the world
      LoseResources(resources);
    }
    //Check if horizontal transmission can occur and do it
    HorizontalTransmission(location);
    //Age the organism
    GrowOlder();
    //Check if the organism should move and do it
    if (my_host.IsNull() && my_config->FREE_LIVING_SYMS() && !dead) {
      //if the symbiont should move, and hasn't been killed
      my_world->MoveFreeSym(location);
    }
  }

  /**
   * Input: None
   *
   * Output: The pointer to the newly created organism
   *
   * Purpose: To produce a new symbiont, identical to the original
   */
  emp::Ptr<BaseSymbiont> MakeNew() {
    emp::Ptr<Symbiont> new_sym = emp::NewPtr<Symbiont>(random, my_world, my_config, GetIntVal());
    new_sym->SetInfectionChance(GetInfectionChance());
    return new_sym;
  }

  /**
   * Input: None
   *
   * Output: The pointer to the newly created organism
   *
   * Purpose: To produce a new symbiont; does not remove resources from the parent, assumes that is handled by calling function
   */
  emp::Ptr<BaseSymbiont> ReproduceSym() override {
    emp::Ptr<BaseSymbiont> sym_baby = MakeNew();
    sym_baby->Mutate();

    if(my_config->PHYLOGENY() == 1){
      my_world->AddSymToSystematic(sym_baby, my_taxon);
      //baby's taxon will be set in AddSymToSystematic
    }
    return sym_baby;
  }

  /**
   * Input: The location of the organism (and it's Host) as a size_t
   *
   * Output: None
   *
   * Purpose: To check and allow for horizontal transmission to occur
   */
  void HorizontalTransmission(emp::WorldPosition location) {
    if (my_config->HORIZ_TRANS()) { //non-lytic horizontal transmission enabled
      double required_points = my_config->SYM_HORIZ_TRANS_RES();
      if (my_config->FREE_LIVING_SYMS() && my_host == nullptr && my_config->FREE_SYM_REPRO_RES() > -1) {
        required_points = my_config->FREE_SYM_REPRO_RES();
      }
      if (GetPoints() >= required_points) {
        // symbiont reproduces independently (horizontal transmission) if it has enough resources
        //TODO: try just subtracting points to be consistent with vertical transmission
        //points = points - my_config->SYM_HORIZ_TRANS_RES();
        SetPoints(0);
        emp::Ptr<BaseSymbiont> sym_baby = ReproduceSym();
        emp::WorldPosition new_pos = my_world->SymDoBirth(sym_baby, location);

        //horizontal transmission data nodes
        emp::DataMonitor<int>& data_node_attempts_horiztrans = my_world->GetHorizontalTransmissionAttemptCount();
        data_node_attempts_horiztrans.AddDatum(1);

        emp::DataMonitor<int>& data_node_successes_horiztrans = my_world->GetHorizontalTransmissionSuccessCount();
        if(new_pos.IsValid()){
          data_node_successes_horiztrans.AddDatum(1);
        }
      }
    }
  }
};
#endif
