#ifndef PGGHOST_H
#define PGGHOST_H

#include "../default_mode/Host.h"
#include "PGGSymbiont.h"
#include "PGGWorld.h"


class PGGHost: public Host {
protected:

  /**
    *
    * Purpose: Represents the collective resource pool held by the host.
    *
  */
  double sourcepool = 0;

  /**
    *
    * Purpose: Represents the world that the PGGHosts are living in.
    *
  */
  emp::Ptr<PGGWorld> my_world = NULL;

public:
  PGGHost(emp::Ptr<emp::Random> _random, emp::Ptr<PGGWorld> _world, emp::Ptr<SymConfigBase> _config,
  double _intval =0.0, emp::vector<emp::Ptr<BaseSymbiont>> _syms = {},
  emp::vector<emp::Ptr<BaseSymbiont>> _repro_syms = {},
  double _points = 0.0) : Host(_random, _world, _config, _intval,_syms, _repro_syms, _points),
  Organism(_config, _world, _random, _points) {my_world = _world;}


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To force a copy constructor to be generated by the compiler.
   */
  PGGHost(const PGGHost &) = default;


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To force a move constructor to be generated by the compiler
   */
  PGGHost(PGGHost &&) = default;


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To tell the compiler to use its default generated variants of the constructor
   */
  PGGHost() = default;

  /**
  * Input: None
  * 
  * Output: Name of class as string, PGGHost
  *
  * Purpose: To know which subclass the object is
  */
  std::string const GetName() const override {
    return  "PGGHost";
  }

  /**
   * Input: None
   *
   * Output: The double representing the resource pool.
   *
   * Purpose: To return the double representing the resource pool.
   */
  double GetPool() {return sourcepool;}


  /**
   * Input: A double to be set as the resource pool.
   *
   * Output: None
   *
   * Purpose: To set the number of resources in the resource pool.
   */
  void SetPool(double _in) {sourcepool= _in;}


  /**
   * Input: A double to be added to the resource pool.
   *
   * Output: None
   *
   * Purpose: To add resources into the host's resource pool.
   */
  void AddPool(double _in) {sourcepool += _in;}


  /**
   * Input: A double quantity of resources to be distributed.
   *
   * Output: None
   *
   * Purpose: To distribute resources to symbionts and collect resource
   * donations from them.
   */
  void DistribResources(double resources) {
    Host::DistribResources(resources);

    for(size_t i=0; i < syms.size(); i++){
      emp::Ptr<PGGSymbiont> sym = syms[i].DynamicCast<PGGSymbiont>();
      if (sym == nullptr) {
        throw "Non-PGG symbiont in PGG host";
      }
      double hostPool = sym->ProcessPool();
      this->AddPool(hostPool);
    }
    if(syms.size()>0){this->DistribPool();}
  } //end DistribResources


  /**
   * Input: None
   *
   * Output: None
   *
   * Purpose: To distribute the resource pool across the hosted symbionts, each donation
   * multiplied by PGG synergy, and then set the resource pool to 0.
   */
  void DistribPool(){
    //to do: marginal return
    int num_sym = syms.size();
    double bonus = my_config->PGG_SYNERGY();
    double sym_piece = (double) sourcepool / num_sym;
    for(size_t i=0; i < syms.size(); i++){
        syms[i]->AddPoints(sym_piece*bonus);
    }
    this->SetPool(0);
  }

  /**
   * Input: None
   *
   * Output: A new PGGHost with same properties as this PGGHost.
   *
   * Purpose: To avoid creating an organism via constructor in other methods.
   */
  emp::Ptr<Organism> MakeNew() override {
    emp::Ptr<PGGHost> host_baby = emp::NewPtr<PGGHost>(random, my_world, my_config, GetIntVal());
    return host_baby;
  }

};//PGGHost

#endif
